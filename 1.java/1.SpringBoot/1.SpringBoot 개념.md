* ApplicationContext 생성하기
    ApplicationContext context = new ClassPathXmlApplicationContext("config.xml")

* ApplicationContext 종류
    ClassPathXmlApplicationContext - 내 클래스 경로 아래
    FileSystemXmlApplicationContext - drive 어딘가
    XmlWebApplicationContext - web에 두고 url 지정
    AnnotationConfigApplicationContext - 파일 지정이 아닌 Annotaion으로 지정한 뒤, 스캔하여 사용



Componet 객체 생성 방법

1. Component Scan 사용하는 방법

@SpringBootApplication -> @ComponentScan => 이 어노테이션이 붙어있는 곳 부터 하위로 @Component를 찾아봐라
@Component => @Service, @Configuration, @Controller, @Component, @Repository

@Repository는 SpringBoot JPA에서 특정한 인터페이스를 상속 받고 있는 구현체를 찾아서 내부적으로 만든다.
=> @Transactional이 붙어 있다면

2. 빈으로 직접 등록하는 방법


Component 객체 꺼내는 방법

1. ApplicationContext에서 직접 꺼내서 사용
2. Autowired를 사용
	1) 필드, 생성자 등 다양하게 사용 가능


=> 생성자
private final OwnerRepository owners;
    private VisitRepository visits;


    public OwnerController(OwnerRepository clinicService, VisitRepository visits) {
        this.owners = clinicService;
        this.visits = visits;
    }

=> 필드
 @Autowired
    private OwnerRepository owners;


=> Setter
private OwnerRepository owners;

  @Autowired
    public void setOwners(OwnerRepository owners){
        this.owners = owners;
    }

=> 어떤 방법을 쓰면 좋나? 생성자를 만들어서 쓰는 방법이 스프링 레퍼런스
==> 순환 참조 발생 경우 - A->B참조 B->A참조
===> 이럴때, 필드 Injection이나 Setter를 사용하면 된다.


스프링 트라이앵글  IOC AOP PSA

IOC (Inversion Of Control)
=> 다양한 구현 방법
	1) 어노테이션 이용
	2) Bean을 직접 생성하는 방법

	꺼내는 다양한 방법
	1) 생성자 이용
	2) 필드 이용
	3) Setter 이용

AOP (Aspect Oriented Programing) => 관심사 집중?
	1) 똑같은 코드인데 흩어져 있을 때
	=> 코드가 없는데도 코드가 있는거처럼 동작한다.

=> 다양한 구현 방법
	1) 컴파일				A.java -> AOP -> A.class (AspectJ 툴)
	2) 바이트코드 조작	A.java -> A.class -> AOP -> 메모리 (AspectJ) ( java 파일을 run할 때, classloader가 class를 읽어서 메모리에 올려서 작업하는데 이 때, 조작한다. )
	3) 프록시 패턴			스프링 AOP가 사용하는 방법 ( 디자인 패턴 중 하나를 사용 - 프록시 패턴 )




=> 스프링 AOP
==> PROXY 서버를 두는 것


// Cach (Target 어떤 Aspect를 적용할)
OwnerController

@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface LogExecutionTime {

}

// CashPerf
@Component
@Aspect
public class LogAspect {

    Logger logger = LoggerFactory.getLogger(LogAspect.class);

    @Around("@annotation(LogExecutionTime)")
    public Object logExecutionTime(ProceedingJoinPoint joinPoint) throws Throwable{
        StopWatch stopWatch = new StopWatch();
        stopWatch.start();

        Object proceed = joinPoint.proceed();

        stopWatch.stop();
        logger.info(stopWatch.prettyPrint());

        return proceed;
    }
}



PSA ( Portable Service Abstraction )
=> 서블릿 어플을 만들어 쓰지만 서블릿을 한번도 만들지 않았다.

@GetMapping
@PostMapping

=> PSA 적용 기술 Spring MVC Model View Controller

@Controller
요청을 메서드와 매핑한다. ( GET / POST )

WHY?
	1) 편의성
	2) spring5 webflux 기술을 사용해서 굉장히 portable하게 기술 스택을 바꿀 수 있다.
		cpu개수만큼의 thread를 유지
		Tomcat -> netty 기반

스프링 트랜잭션
@Transactional => data를 처리할 때, a,b,c가 다 되어야 하나의 작업이 완료되는 경우, 이때 a~c까지의 하나의 작업을 트랜잭션이라함 ( all or nothing )

jdbc transaction의 가장 간단한 코드도 아래의 과정을 거친다.
1. connection.setAutoCommit(false)
2. sql data insert
3. connection.commit
4. 예외 처리 ( rollback )

But Spring에선 @Transactional을 사용해서 명시적으로 위와 같은 코딩을 할 필요가 없다.

==============================================================================

아주 고전적인 spring xml 사용법

<bean id="bookService" class="com.test.spring.BookService"
		scope="", autowired="">
        <property name="bookRepository" ref="bookRepository"/>

</bean>

<bean id="bookRepository" class="com.test.spring.BookRepository">

</bean>

	1. bean 설정 중 scope는 singleton, autowired는 default가 기본 값이다.
		=> scope는 prototype, session 등으로 줄 수도 있다.

	2. 두 개의 Bean을 선언하더라도 의존성을 선언해줘야한다.
	<property> 여기서 name은 클래스의 setter에서 가져오는 것.


	가장 큰 단점 => 일일히 bean으로 등록하는게 굉장히 번거롭다.

=>> 나는 아래 패키지 하위는 모두 bean으로 등록해서 사용하겠다.
	<context:component-scan base-package="com.test.spring" />
	=> @Componet를 상속 받는 어노테이션들을 bean으로 관리를하겠다.
ApplicationContext applicationContext = new ClassPathXmlApplicationContext("application.xml");
		String[] beanDefinitionNames = applicationContext.getBeanDefinitionNames();
        System.out.println(Arrays.toString(beanDefinitionNames));


@Configuration 어노테이션을 사용해서 @Bean을 직접 만들어 사용
ApplicationContext applicationContext = new AnnotationConfigApplicationContext(ApplicationConfig.class);


=> @Bean을 만드는거조차 하고 싶지 않다. @ComponetScan 어노테이션을 사용하라.
@Configuration
@ComponentScan(basePackageClasses = DemoApplication.class)


=> 이제는 Configuration 클래스조차 필요 없다.
@SpringBootApplication


==============================================================================

* 빈 주입 방법
	1. 빈이 없을 때
		빈을 정의 해라.
		1) 필드
		2) 생성자
		3) setter
	2. 빈이 한 개 일 때

	3. 빈이 여러개 일 때
		@Primary
		@Qualify
		또는 같은 이름의 빈을 찾으면 된다. (스몰케이스)

* 빈 생성 후 바로 할 일 정의
	방법 1.
	@PostConstruct
	public void setUp()
	{
	}

	방법 2.
	public class BookService implements InitializingBean{
		@Override
		public void afterPropertiesSet() throws Exception {

		}
	}



==============================================================================

@ComponentScan 는 모든 것을 스캔하지 않는다. 선언 위치의 하위 패키지들만

또는 filter 옵션으로 어떤 어노테이션을 무시할지

싱글톤 scope은 구동시 초기 타임을 많이 먹는다. 전체를 한번에 등록을 하기 때문에
=> 초기 구동시 구동 타임이 문제가 된다면 펑션을 사용한 빈 등록 방법이 있다.

 var app = new SpringApplication(DemoApplication.class);
        app.addInitializers((ApplicationContextInitializer<GenericApplicationContext>) ctx -> {
            ctx.registerBean(ComponentTest.class);
            ctx.registerBean(ApplicationRunner.class, () -> args1 -> System.out.println("Functional Bean!!"));
        });
        app.run(args);


* Spring Bean Life Cycle

1. 빈 인스턴스화 및 DI
	1) xml / 자바 설정 / 어노테이션 / 빈 정의를 스캔
	2) 빈 인스턴스 생성
	3) 빈 프로퍼티에 의존성 주입

2. 스프링 인지 여부 검사
	1) 빈이 BeanNameAware 인터페이스를 구현 시 setBeanName() 호출
	2) 빈이 BeanClassLoaderAware 인터페이스 구현 시 setBeanClassLoader() 호출
	3) 빈이 ApplicationContextAware 인터페이스 구현 시 setApplicationContext() 호출

3. 빈 생성 생명 주기 콜백
	1) @PostConstruct 어노테이션 적용 메소드 호출
	2) 빈이 InitializingBean 인터페이스를 구현 시 afterPropertiesSet() 호출
	3) 빈이 Init-method 정의하면 xml<bean>에서 지정한 메서드 호출

4. 빈 소멸 생명 주기 콜백
	1) @PreDestroy 어노테이션 적용 메서드 호출
	2) 빈이 DispoableBean 인터페이스 구현 시 destory() 호출
	3) 빈이 destory-method 정의하면 xml <bean> 에서 지정한 메서드 호출
	prototype 스코프 빈에서는 호출되지 않음


==============================================================================

* 생성자를 통한 의존성 주입은 빈 생성 당시에도 개입이 된다. 생성자를 전달 받아야하는 타입에 해당하는 빈이 없으면 인스턴스를 만들지 못한다.
* 만약 주입을 해야하는 빈이 여러개라면? -> 모든 빈을 다 받거나, @primary 어노테이션을 쓰거나, @Qualifyer 어노테이션을 쓰거나
* 단, @Primary 어노테이션을 사용하는 방법이 좋다.

	@Autowired @Qualifier(value = "sooBookRepository")
    private BookRepository bookRepository;

    @Autowired
    BookRepository myBookRepository;

    public void printBookRepository(){
        System.out.println(myBookRepository);
    }


@Repository
@Primary
public class MyBookRepository implements BookRepository {

}

* 의존성을 optional로 줄 수 있다.
* setter나 필드로 의존성을 주입하는 경우 bookService 자체는 만들어져야하는거 아닌가? bookRepository가 null이라도
* 이럴때 required를 false로 두면 된다.
**/
    @Autowired(required = false)
    public void setBookRepository(BookRepository bookRepository) {
        this.bookRepository = bookRepository;
    }
==============================================================================

* Scope
	- Singleton @Component
	- Proto type @Component @Scope("prototype")

	Proto type Bean에 Singleton type Bean을 사용하면 아무런 상관이 없다.

	어차피 Singleton Type은 항상 같은 객체를 가져가므로 문제가 없다.

	다만 Singleton Type의 Bean에 ProtoType의 bean을 사용해서 singleton 객체를 쓰면 singleton 내의 proto type의 bean의 instance가 바뀌지 않는다.
	=> singleton instance는 한번만 생성되서 사용되므로

	* 이것을 해결하는 방법 중 여러가지가 있지만 쓰기 쉬운 방법은 proxy mode(쓰기는 쉬우나 이해하기 어려움)

	1.
	@Component @Scope(value = "prototype",proxyMode = ScopedProxyMode.TARGET_CLASS)

	이것을 사용하게 되면 cg library를 사용한 다이나믹 프록시를 사용하게 된다. => 무슨말?

	=> 해당 타입의 proto type을 proxy로 감싸라. => proto type은 매번 바뀌어야 되므로

	2.
	@Autowired
    private ObjectProvider<Proto> proto;

    Proto getProto() {
        return proto.getIfAvailable();
    }

=> scope가 넓은 Singleton 객체 (생명주기가 길다)
	짧은 생명주기를 가진 빈들을 주입 받을 때는 필요할 수 있다.

	singleton 객체는 property가 항상 공유된다.

	이때, singleton 객체의 property가 항상 thread safety하다고 보장할 수 없다.




==============================================================================
# 8. Environment - profile

ApplicationContext > EnvironmentCapable > profile 기능
: 빈들의 그룹
: 각각의 환경에 따라 다른 빈들을 써야하는 경우
: 활성화할 프로파일 확인 및 설정



1. profile로 정의할 bean을 만들어 사용할 경우
@Componet
@Profile("test")
public class TestConfiguration{
	@Bean
	BookRepository bookRepository;
}

2. component scan으로 정의한 bean에도 등록할 수 있다.
@Repository
@Profile("test")
public class TestBookRepository implements BookRepository {
}

이런 표현도 가능하나, 굳이 복잡하게 구성할 필요가 없다.
항상 간단하게 가장 좋은 것.
* @Profile("test") ("!test") @Profile("!test & prod")

* 적용 방법

spring vmoption -Dspring.profiles.active="test"

==============================================================================

# 9. Environment - property

Application에서 등록된 key-value 쌍으로 되어있는 property에 접근
OS옵션, VM옵션 등

1.
vmoption - -Dapp.name=Spring5

2.
app.properties 작성

@PropertySource("classpath:/app.properties")

Environment environment = ctx.getEnvironment();
        System.out.println(environment.getProperty("app.name"));

		이렇게 사용 가능하다.

=> 우선순위는 vmoption이 더 높다.

==============================================================================

# 10. MessageSource
국제화 기능을 제공하는 인터페이스

ApplicationContext > MessageSource

1. resource 파일에 아래 파일 생성
messages.properties > greeting=Hello {0}
messages_ko_KR.properties > greeting=안녕, {0}

2. Runner
	@Autowired
    MessageSource messageSource;
    @Override
    public void run(ApplicationArguments args) throws Exception {
        while (true){
            System.out.println(messageSource.getMessage("greeting",new String[]{"seongsoo"}, Locale.KOREA));
            System.out.println(messageSource.getMessage("greeting",new String[]{"seongsoo"}, Locale.ENGLISH));
            Thread.sleep(1000);
        }
    }

2. reloadable 객체 생성
	@Bean
    public MessageSource messageSource(){
        var messageSource = new ReloadableResourceBundleMessageSource();
        messageSource.setBasename("classpath:/messages");
        messageSource.setDefaultEncoding("UTF-8");
        messageSource.setCacheSeconds(3);	=> 3초마다 캐싱
        return messageSource;
    }

=> Reloadable message이기 때문에 Application 기동중에 message를 바꾸더라도 빌드만 해주면 해당 값이 실시간으로 바뀐다.


==============================================================================

# 11.

ApplicationContext > ApplicationEventPublisher

: observer 패턴의 구현체로 이벤트 기능 구현에 적합


1. spring 4.2 이전에는 아래처럼 구현
public class MyEvent extends ApplicationEvent {
    private int data;
    /**
     * Create a new ApplicationEvent.
     *
     * @param source the object on which the event initially occurred (never {@code null})
     */
    public MyEvent(Object source) {
        super(source);
    }

    public MyEvent(Object source, int data) {
        super(source);
        this.data = data;
    }

    public int getData() {
        return data;
    }
}


@Component
public class MyEventHandler implements ApplicationListener<MyEvent> {

    @Override
    public void onApplicationEvent(MyEvent event) {
        System.out.println("이벤트를 받았다. 데이터는 "+event.getData());
    }
}

2. spring 4.2 이후에는 ApplicationEvent를 상속받지 않아도 된다.
	=> 이것이 spring이 추구하는 철학
	=> 비침투성 ( 아래 코드에는 spring 패키지가 전혀 들어있지 않다. -> POJO )
	=> 테스트, 코드 유지보수 장점 증가

public class MyEvent {
    private int data;
	private Object source;

    public MyEvent(Object source, int data) {
        this.source = source;
        this.data = data;
    }

	public Object getObject(){
		return object;
	}

    public int getData() {
        return data;
    }
}

@Component
public class MyEventHandler{

    @EventListener
	@Order(Ordered.HIGHEST_PRECEDENCE)
    public void onApplicationEvent(MyEvent event) {
        System.out.println("이벤트를 받았다. 데이터는 "+event.getData());
    }
}


=> 이벤트 핸들러는 여러개 사용할 수 있다.
=> 동작은 랜덤하게 순차적으로 실행된다.
=> 순서를 부여하고 싶다면 @Order() 어노테이션을 사용하면 된다.
=> Async하게 실행하고 싶다면 @Async 어노테이션을 쓸 수 있다. 이때, @Order는 더이상 의미가 없다.


==============================================================================

# 12. ResourceLoader

: resource 읽어오기

Resource resource = resourceLoader.getResource("classpath:test.txt");
System.out.println(resource.exists());
System.out.println(resource.getDescription());

	리소스읽어오기
	●파일시스템에서읽어오기
	●클래스패스에서읽어오기
	●URL로읽어오기
	●상대/절대경로로읽어오기


==============================================================================

=> Application Context는 Bean Factory 뿐만 아니라, EventHandler, ResourceLoader, Message 등 여러 역할을 한다.
=> 지금까지는 spring IOC에 대해 살펴봤다면 지금부터는 추상화 중의 일부분을 알아보겠다.

# 13. Resource 추상화

: java.net.URL을 추상화 (클래스를 감싼 것)

var ctx= new FileSystemXmlApplicationContext("xx.xml");
var ctx1= new ClassPathXmlApplicationContext("xxx.xml");

=> 파일 시스템 경로 기준 / 클래스 경로 기준
=> Resource의타입은 locaion 문자열과​ ApplicationContext의 ​타입​에 따라 결정된다.

가장 추천하는 방법 : 접두어를 사용 ( 명시적으로 )
classpath:​​me/whiteship/config.xml -> ClassPathResource
file://​​/some/resource/path/config.xml -> FileSystemResource


==============================================================================

# 14. Validation 추상화

: 주로 Spring MVC에서 사용
: Application이 계층형으로 이루어져 있다면 어디서든 사용 가능
: 객체 검증용 인터페이스
: java EE 표준 스펙

	@Override
    public void validate(Object target, Errors errors) {
		1. validationUtil 사용 방법
        ValidationUtils.rejectIfEmptyOrWhitespace(errors,"title","notempty","Empty title is now allowed.");

		2. validationUtil 사용하지 않는 방법
        Event event = (Event) target;
        if (event.getTitle()==null) {
            errors.reject("notempty","Empty title is now allowed.");
        }
    }



	@Autowired
    Validator validator;

	@NotEmpty
    String title;
    @Min(0)
    Integer limit;
    @Email
    String email;

	Errors errors = new BeanPropertyBindingResult(event,"event");

    validator.validate(event,errors);


==============================================================================

# 15. 데이터 바인딩 추상화
: 사용자 입력값을 어플리케이션 도메인 모델에 동적으로 변환해 넣어주는 기능
=> 문자열 입력값을 int,long,boolean,Data 뿐만 아니라 object Event, Book으로도 변환해서 넣어준다.


Property Editor들은 Thread Safety 하지 않다.
=> Property Editor는 Bean으로 등록해서 쓰면 안된다.

public class EventEditor extends PropertyEditorSupport {
    @Override
    public String getAsText() {
        Event value = (Event) getValue();
        return value.getId().toString();
    }

    @Override
    public void setAsText(String text) throws IllegalArgumentException {
        setValue(new Event(Integer.parseInt(text)));
    }
}

=> 꼭 필요하면 Thread Scope Bean으로 만들어서 사용하면 된다.

=> 그럼 어떻게 EventEditor 클래스를 사용하나?
=> 아래처럼 @InitBinder 어노테이션을 사용해라.
	@InitBinder
    public void init(WebDataBinder webDataBinder){
        webDataBinder.registerCustomEditor(Event.class,new EventEditor());
    }


=> 하지만 이것은 아주 고전적인 데이터 바인딩 방법, 스프링3부터는 진화된 방법을 제안



==============================================================================

# 16. 데이터 바인딩 추상화 : Convert와 Formatter

PropertyEditor => Converter

=> Thread Safety하다. => Bean으로 등록 가능하다.


1. converter
	public static class StringToEventConverter implements Converter<String,Event>{

        @Override
        public Event convert(String source) {
            return new Event(Integer.parseInt(source));
        }
    }

	=> Converter를 registry에 등록해서 사용 가능하다.

	@Configuration
	public class WebConfig implements WebMvcConfigurer {
    @Override
    public void addFormatters(FormatterRegistry registry) {
        registry.addConverter(new EventConverter.StringToEventConverter());
    }
	}


@Configuration
public class WebConfig implements WebMvcConfigurer {
    @Override
    public void addFormatters(FormatterRegistry registry) {
//        registry.addConverter(new EventConverter.StringToEventConverter());
        registry.addFormatter(new EventFormatter());
    }
}


2. formatter

	public class EventFormatter implements Formatter<Event> {
    @Override
    public Event parse(String text, Locale locale) throws ParseException {
        return new Event(Integer.parseInt(text));
    }

    @Override
    public String print(Event object, Locale locale) {
        return object.getId().toString();
    }
}

3. conversion service bean을 등록받아서 사용

	@Autowired
    ConversionService conversionService;

=> 직접 이렇게 구현해서 사용할 일은 거의 없을 것이다.

=> converter는 bean으로 등록해도 안전하다.

class WebConfig implements WebMvcConfigurer => registry를 따로 등록하지 않아도

EventFormatter 클래스 자체를 Bean으로 등록하고 실행해도 잘 동작한다.

=> 추천하는 방법은 Formatter를 사용한다. 또한 데이터 바인딩은 주로 Web과 관련된 곳에서 사용할 것이다.
datetime formatter를 많이 사용한다.


==============================================================================

# 17. SpEL(Spring Expression Language)
: EL과 비슷한 기능도 필요하지만 메소드 호출을 지원하면 문자열 템플릿 기능도 제공한다.


AOP (Aspect Oriented Programming) - 프록시 패턴(스프링)
IOC (Inversion of Control) - DI(Dependency Injection)
PSA (Portable Service Abstract) - Annotation @Transaction, @PUT @POST 등

# 18. Spring AOP (Aspect Orient Programming)
: 관전 지향 프로그래밍



==============================================================================

* DI를 해야하는 이유
=> new 생성자를 직접 생성하는 경우, 수정 사항이 생길 때 마다 소스를 수정해줘야 한다.
    매우 불합리

=> 설정 파일(Application Context)로 지정해준다면 소스의 수정없이 설정 파일 수정만으로도 원하는 기능을 구현할 수 있다.
=> 설정 파일 지정보다 더 간단한 방법이 어노테이션 지정 방법이다.
































