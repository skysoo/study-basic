# RxJava

## 1. 기본

Recative 프로그래밍이란?

복잡한 비동기 프로그램을 효과적으로 처리하기 위한 라이브러리이다.

RxJava는 넷플릭스(Netflix)의 기술 블로그에서 처음 소개되었다. 그 당시 넷플릭스는 REST 기반의 서비스 API 호출 횟수와 서비스의 전반적인 성능을 개선하는 프로젝트를 진행했고, 그결과 .NET 환경의 리액티브 확장 라이브러리(Rx)를 JVM에 포팅하여 RxJava를 만들었다. 넷플릭스에서 RxJava를 만들게된 핵심적인 이유를 다음과 같이 밝혔다.

- 동시성을 적극적으로 끌어안을 필요가 있다(Embrace Concurrency)

- 자바 Future를 조합하기 어렵다는 점을 해결해야 한다(Java Futures are Expensive to Compose)

- 콜백 방식의 문제점을 개선해야 한다(Callbacks Have Their Own Problems)

첫번째 이유의 원인은 자바가 동시성 처리를 하는데 번거로움이 있기 때문이다. 이를 해결하려고 넷플릭스는 클라이언트의 요청을 처리하는 서비스 계층(service layer)에서 동시성을 적극적으로 끌어안았다. 클라이언트의 요청을 처리할때 다수의 비동기 실행 흐름(스레드 등)을 생성하고 그것의 결과를 취합하여 최종 리턴하는 방식으로 내부 로직을 변경했다.

두번째 이유의 원인은 2013년 당시 자바8에서 제공하는 CompletableFuture 같은 클래스가 제공되지 않았기 때문이다. 그래서 비동기 흐름을 조합할 방법이 거의없었다. RxJava에서는 이를 해결하려고 비동기 흐름을 조합(compose)할 수 있는 방법을 제공한다. RxJava에서는 조합하는 실행 단위를 리액티브 연산자(Operators)라고 한다.

세번째 이유의 원인은 콜백이 콜백을 부르는 콜백 지옥(Callback Hell) 상황이 코드의 가독성을 떨어뜨리고 문제 발생시 디버깅을 어렵게 만들기 때문이다. 비동기 방식으로 동작하는 가장 대표적인 프로그래밍 패턴은 콜백이다. 그래서 RxJava는 콜백을 사용하지 않는 방향으로 설계해 이를 해결했다. 그래서 RxJava는 콜백을 사용하지 않는 방향으로 설계해 이를 해결했다.

리액티브 프로그래밍은 비동기 연산을 필터링, 변환, 조합해 위 세가지 핵심이유를 해결할 수 있다. 따라서 RxJava는 Observable과 같은 데이터 소스와 map(), filter(), reduce()와 같은 리액티브 연산자를 제공한다.

RxJava는 2016년 10월에 완전히 새로 작성한 RxJava 2.0을 발표했다. RxJava 2.0은 RxJava 1.x를 Reactive-Streams 스펙 기반으로 새롭게 개선한 것이므로 공통점도 많고 차이점도 많다.

Reactive-Stream 스펙은 자바8에 도입된 Stream API와 Observable 기반의 리액티브 프로그래밍을 포괄하는 표준 스펙으로 자바 9에 도입되었다.

#### 1-1-1. 명령형 프로그래밍

```java
List<Integer> numbers = Arrays.asList(1,3,21,10,8,11);
int sum = 0;

for(int number : numbers) {
    if(number > 6 && (number % 2 != 0)){
        sum += number;
    }
}

System.out.println("# 명령형 프로그래밍 사용 : "+ sum);
```

#### 1-1-2. 선언형 프로그래밍

```java
List<Integer> numbers = Arrays.asList(1,3,21,10,8,11);

int sum = numbers.stream()
        .filter(number -> number > 6 && number % 2 != 0)
        .mapToInt(Integer::intValue)
        .sum();

System.out.println("# 선언형 프로그래밍 사용 : "+ sum);
```

## 1-2. 리액티브의 개념이 적용된 예시

![rxjava1](../99.Img/Rxjava1.png)

## 1-3. 리액티브 프로그래밍을 위해 알아야 할 것들

전통적인 스레드 기반 프로그래밍은 여러 스레드가 동시ㄴ에 실행되므로 개발자가 예상하지 못한 이슈가 많이 발생하고 재현조차 어려웠다. 그래서 부수 효과가 없는 순수 함수를 지향하는 함수형 프로그래밍 기법을 이용해서 작성된 함수가 리액티브 연산자 함수가 되겠다.

![rxjava2](../99.Img/Rxjava2.png)

#### 1-3-1. 리액티브 프로그래밍 예시

```java
public static void main(String[] args) {
    Observable.just(100,200,300,400,500) // 발행
            .doOnNext(data -> System.out.println(getThreadName() + " : #doOnNext() : "+ data))
            .subscribeOn(Schedulers.io()) // main Thread가 아닌 다른 스레드에서 실행한다.
            .observeOn(Schedulers.computation())
            .filter(number->number > 300) // 가공
            .subscribe(num -> System.out.println(getThreadName() + " : result : "+num)); // 처리
}

public static String getThreadName() {
    return Thread.currentThread().getName();
}
```

#### .doOnNext(data -> System.out.println(getThreadName() + " : #doOnNext() : "+ data))

![rxjava3](../99.Img/Rxjava3.png)

#### .subscribeOn(Schedulers.io()) // main Thread가 아닌 다른 스레드에서 실행한다.

> 데이터의 발행, 흐름을 결정하는 스레드를 지정

![rxjava4](../99.Img/Rxjava4.png)

#### .observeOn(Schedulers.computation())

> 발행된 데이터를 가공하고 구독하여 처리하는 스레드를 지정

![rxjava5](../99.Img/Rxjava5.png)

> subscribeOn() 과 observeOn() 는 스케줄러를 지정하는 함수이다.

## 2. 마블 다이어그램

리액티브 프로그래밍의 실행 순서를 도식화 한 것이다.

> Java8의 Stream API 와 RX java 차이점

![rxjava6](../99.Img/Rxjava6.png)

## 3. Reactive Streams란?

Publisher, Subscriber, Subscription, Processor 4개의 인터페이스를 제공한다.

- Publisher : 데이터를 생성하고 통지한다.
- Subscriber : 통지된 데이터를 전달 받아서 처리한다.
- Subscription : 전달 받은 데이터의 개수를 요청하고 구독을 해지한다.
- Processor : Publisher와 Subscripber의 기능이 모두 있다.

![rxjava7](../99.Img/Rxjava7.png)

### 3-1. Cold Publisher & Hot Publisher

![rxjava8](../99.Img/Rxjava8.png)

![rxjava9](../99.Img/Rxjava9.png)

![rxjava10](../99.Img/Rxjava10.png)

## 4. Observable과 Flowable에 대한 이해

### 4-1. 비교

![rxjava11](../99.Img/Rxjava11.png)

### 4-2. 배압이란?

![rxjava12](../99.Img/Rxjava12.png)

아래와 같이 배압을 조절하지 않으면 데이터 처리 과정에서 Error가 발생한다.

```java
/**
 * 배압이 안맞을 때 생기는 이슈 확인
 *
 * 통지되는 데이터보다 소비되는 데이터가 1000배 느리다..
 **/
Flowable.interval(1L, TimeUnit.MILLISECONDS)
        .doOnNext(
                data -> log.info(getThread() + "" +data))
        .observeOn(Schedulers.computation())
        .subscribe(data -> {
                    System.out.print(getThread());
                    System.out.println(" # 소비자 처리 대기 중..");
                    TimeUnit.MILLISECONDS.sleep(1000L);
                    log.info(String.valueOf(data));
                },
                error -> log.error(String.valueOf(error)),
                () -> log.info("Success")
        );

Thread.sleep(2000L);
```

> [RxComputationThreadPool-1] ERROR com.study.rxjava.chapter02.MissingBackPressureSample - io.reactivex.rxjava3.exceptions.MissingBackpressureException: Can't deliver value 128 due to lack of requests

### 4-3. 배압 전략

![rxjava13](../99.Img/Rxjava13.png)
![rxjava14](../99.Img/Rxjava14.png)
![rxjava15](../99.Img/Rxjava15.png)
![rxjava16](../99.Img/Rxjava16.png)
![rxjava17](../99.Img/Rxjava17.png)
