# Java ORM 표준 JPA

### 목표
1. 객체와 테이블을 제대로 설계하고 매핑하는 방법
2. 기본키와 외래키 매핑
3. 1:N, N:1, 1:1, N:M 매핑
4. 실무 노하우 + 성능까지 고려

# 1. 등장 배경
## 1.1 지루한 CURD
* 객체 필드 추가 - 모든 SQL 수정이 불가피하다.

* JDBC
  * java에서 db에 접근하기 위해 사용하는 라이브러리
=> sql문 작성 및 db에 종속적이기 때문에 table,column 변경시 코드 다 변경


## 1.2 패러다임의 불일치
* 객체 vs 관계형 데이터베이스
* 객체 : 추상화, 캡슐화, 정보은닉, 상속, 다형성 지원
* 객체 -> SQL 변환
* 개발자 = SQL 매퍼

RDB는 객체에서의 상속 관계와 유사한 상속이란 개념은 없다. (그나마 유사한것 테이블의 슈퍼타입, 서브타입 관계)

## ORM (Object-relational mapping)

* 객체는 객체대로 설계
* 관계형 DB는 관계형 DB대로 설계
* ORM 프레임워크가 매핑해주겠다.

> JPA는 JAVA 어플과 JDBC 사이에서 동작

* JPA 역할
   - Entity 분석
   - SQL 생성
   - JDBC API 사용
   - 패러다임 불일치 해결

> JDBC > MyBatis, Jdbc Template (SQL Mapper) > JPA

* JPA는 SQL조차 작성할 필요가 없다.
* 자바 컬렉션에 객체를 저장하고 조회하듯이 사용한다.
* JPA가 대신 쿼리를 짜는 것이다.


# 2.JPA 소개

JPA : Java Persistent API

* EJB - 엔티티 빈(자바표준)
  => 성능도 안나오고

* 하이버네이트 - 오픈소스

* JPA - 자바표준
  => 하이버네이트 만든 사람이 와서 다시 만듦


## 2.1 JPA를 왜 사용해야 하는가?
1. 생산성 ( CRUD )
2. 유지보수 ( 기존 필드 변경시 모든 SQL 수정 )
3. 패러다임의 불일치 해결 ( 상속, 연관관계, 객체 그래프 )
4. 성능 최적화 ( 1차 캐시와 동일성 보장, 트랜잭션을 지원하는 쓰기 지연, 지연 로딩 )


### 버전 설정
spring 기준으로 여러 툴을 연동해서 사용할 것이다.
spring boot의 버전 지원 정보를 확인하여 맞는 공식적으로 지원하는 버전을 사용하는 것이 좋다.
> https://docs.spring.io/spring-boot/docs/2.2.5.RELEASE/reference/html/appendix-dependency-versions.html#appendix-dependency-versions


## 2.2 JPQL

JPA는 SQL을 추상화한 객체 지향 쿼리 언어

JPQL은 엔티티 객체를 대상으로 쿼리를 작성한다.

SQL은 테이블을 대상으로 쿼리를 작성한다.

이것의 장점은 DB자체가 바뀌어도 신경쓸 필요가 없다.

# 3. 영속성 컨텍스트

EntityManager.persist(entity);

> entity를 db에 저장하는게 아니라 entity를 영속성 컨텍스트에 저장한다는 뜻

> EntityManager를 통해 영속성 컨텍스트에 접근한다.

영속성 컨텍스트는 논리적인 개념 (눈에 보이지 않음)

### 3.1 영속성 컨텍스트의 이점

1. 엔티티 조회, 1차 캐시
2. 엔티티 등록, 트랜잭션을 지원하는 쓰기 지연 (성능 향샹-불필요한 커넥션을 맺지 않는다)
3. 엔티티 수정, 변경감지 (1차 캐시에 스냅샷 존재한다. - 캐시 안의 엔티티가 변경이 있을 때, update query를 작성한다.)

## 3.2 엔티티의 생명 주기

1. 비영속 (new/transient)
    => 영속성 컨텍스트와 연관된 코드가 없는 경우
2. 영속 (managed)
    => persist(), find()등 객체를 영속성 컨텍스트에 저장하는 단계
3. 준영속 (detached)
    => detach()
4. 삭제 (removed)
   => remove()

> 영속 상태일 때는 db에 쿼리가 날라가지 않고, commit()을 하는 순간 db에 쿼리가 날라감


## 3.3 플러쉬

commit 할 때 일어난다.

영속성 컨텍스트의 반영 내역을 db에 전송한다.

em.flush() 직접 호출 가능

1. 쿼리 실행할 때
2. commit 할 때

FlushModeType.AUTO
FlushModeType.COMMIT (쿼리실행시에는 flush하지 않음(db 내용과 동기화하지 않음 ))

> 플러쉬를 하더라도 1차 캐시에 있는 내용을 지우지는 않는다.


## 3.4 준영속 상태
em.detach(entity) - 특정 entity만 준영속 상태화 / em.clear() / em.close() 실행 시 일어난다.



# 4. JPA 관계 설정

## 4.1 기본키 매핑

@Id - 직접 할당

@GeneratedValue - 자동 생성
  1. AUTO (아래 3가지 중 DB 방언에 맞춰서 자동으로 생성)
  2. Identity - MySQL, PostgreSQL
  3. SEQUENCE - Oracle
  4. TABLE

영속성 컨텍스트에서 관리를 하려면 기본키가 있어야하는데, 시퀀스 자동할당은 db에 값이 들어가봐야 기본키를 알 수 있는 문제가 발생한다.
=> JPA 기본은 commit 시점에 쿼리를 날리지만, Identity 같은 경우는 persist 단계에서 쿼리를 날린다.

> 위와 같은 이유로 Identity를 사용하면 쿼리를 한번에 모아서 날리는 이점이 없어지므로 성능 향상의 이점이 사라진다는 단점이 생긴다.


반면 SEQUENCE는 쿼리를 한번에 모았다가 보내는게 가능하다.
nextcall로 시퀀스id를 미리 가져온다. 어쨌든 이것도 네트워크를 타는것은 사실이다.

> 그래서 allocationSize 라는게 존재한다. 지정한 크기만큼 한번의 nextcall로 가져온다.

## 4.2 단방향 연관 관계

* 방향 : 단방향, 양방향
* 다중성 : 다대일, 일대다, 일대일, 다대다
* 연관관계의 주인 : 객체 양방향 관계는 주인이 있다.


## 4.3 양방향 연관 관계와 연관 관계의 주인1-기초
* 양방향 객체 연관 관계를 표현하더라도 테이블 연관 관계는 변하는게 없다.

* 객체의 양방향 연관 관계는 서로 다른 단방향 연관 관계가 2개로 포인트가 2개이다.
* 테이블의 양방향 연관 관계는 FK키로 포인트가 1개이다.

* 단방향 2개 중 연관관계의 주인 테이블을 정해라.
> 외래키가 있는 곳을 주인으로 정해라.
> 외래키가 있는 곳은 무조건 N이 된다.

~~~java
  Member 테이블
  @ManyToOne
  private Team team;

  Team 테이블
  @OneToMany(mappedBy = "team")
  private List<Member> members = new ArrayList<>();
  ~~~

mappedBy는 조회만 가능하며 가짜 매핑이라한다.

이렇게 해야 성능 이슈와 설계가 깔끔하게 된다.


## 4.3.1 양방향 매핑시 가장 많이 하는 실수
연관관계에서 주인이 아닌 쪽에 값을 셋팅하는 경우
즉, mappedBy쪽의 객체에 값을 셋팅하는 것은 문제가된다. mappedBy는 읽기만 가능하기 때문.

> 1. 따라서 순수 객체 상태를 고려해서 양방향 연관관계를 매핑해줄 때는 항상 양쪽에 값을 설정하자.

* 연관관계 편의 메서드

Team team1 = new Team();
team1.setName("TeamC");
entityManager.persist(team1);

Member member1 = new Member();
member1.setName("박지성");
member1.setTeam(team1);         // ** 포인트1
entityManager.persist(member1);

team1.getMembers().add(member1);  // ** 포인트2


그렇다면 양방향 연관관계 매핑시에 양쪽에 값을 세팅해준다면 이렇게 관리 포인트가 2군데가 된다.

이럴때 2군데 다 일일히 넣어주기 번거롭다 한다면 연관관계의 주인쪽에서 반대편 값까지 한번에 세팅을 해주는 방법이 있다.

~~~java
public void setTeam(Team team) {
        this.team = team;
        team.getMembers().add(this);
}
~~~

이렇게되면 포인트2 관련 코딩을 하지 않아도 된다.

> 2. 연관관계 편의 메서드는 한쪽에만 선언 해주는것이 좋다.

> 3. 양방향 매핑시 무한 루프를 조심하자 toString(), lombok, JSON 생성 라이브러리(entity를 json으로 바꿀때)
* toString() - lombok에서 toString() 쓰지마라.
* JSON 생성 라이브러리 - 컨트롤러에서 entity를 절대 반환하지 마라. -> 필요하다하면 값만 가지는 DTO로 변환해서 반환해라.


# 5. 정리
## 5.1 양방향 매핑 정리

1. 단방향 매핑만으로 이미 연관관계 매핑은 완료해야 한다.
2. 양방향 매핑은 반대 방향으로 조회(객체 그래프 탐색) 기능이 추가된 것 뿐
3. JPQL에서 역방향으로 탐색할 일이 많음
4. 단방향 매핑을 잘 하고 양방향은 필요할 때 추가해도 됨(테이블에 영향을 주지 않음)

## 5.2 연관관계의 주인을 정하는 기준

1. 비즈니스 로직을 기준으로 연관관계의 주인을 선택하면 안됨
2. 연관관계의 주인은 외래키의 위치를 기준으로 정해야함 (@OneToMany - Team > Member)


## 5.3 단방향 연관 관계 만으로도 개발하는데 및 설계도 다 가능하다.

1. But 개발 상의 편의, 조회 등을 위해서는 양방향
2. 실무에서 보다 복잡한 쿼리를 사용하면서 JPQL 사용시 양방향으로 조회해야할 일이 생긴다.

> 핵심은 단방향으로 설계를 하는게 가장 깔끔하고 조금 더 객체 지향적으로 코딩을 하고 싶다할 때 양방향을 써라. -> 비즈니스 관계를 잘 파악해야 한다.



## 5.4 다양한 연관 관계 매핑

* 고려 사항
  * 다중성
  * 단방향, 양방향
  * 연관관계의 주인

1. 다대일[N:1] - @ManyToOne - 연관관계의 주인 (FK) 자연스럽다

2. 일대다[1:N] - @OneToMany - One에 연관관계의 주인 (FK)
    1. 단방향 매핑
    => 일대다 단방향 매핑을 할 수 있지만 권장하진 않는다. => 엔티티가 관리하는 외래키가 다른 테이블에 있다.(어마어마한 단점)
    => 쿼리상에서 헷갈리는 경우가 많이 발생한다.
    => @JoinColumn을 꼭 사용해야한다. 그렇지 않으면 조인 테이블 방식을 사용한다. => 중간 테이블을 하나 생성해버린다.

    1. 양방향 매핑
    @ManyToOne
    @JoinColumn(name = "COMPANY_ID", insertable = false, updatable = false)
    private Company company;

> 일대다 단방향 매핑 보다는 다대일 양방향 매핑으로 설계하는 것을 권장 (설계적으로 조금 손해를 보더라도)

> 연관관계의 주인이라함은 Insert, Update가 가능하다는 것. 즉, 연관관계의 주인만 데이터에 대한 Insert, Update를 할 수 있어야 한다.


3. 일대일[1:1] - @OneToOne
    1. 주 테이블이나 대상 테이블 중에서 외래키 선택
    2. 양방향 매핑하려면 반대편에 mappedBy 적용

  - 주 테이블에 외래키
    - 주 객체가 대상 객체의 참조를 가지는 형식
    - 객체지향 개발자 선호
    - JPA 매핑 편리
    - 장점: 주 테이블만 조회해도 대상 테이블에 데이터가 있는지 확인 가능
    - 단점: 값이 없으면 외래키에 null 허용

  - 대상 테이블에 외래키
    - 전통적인 데이터베이스 개발자 선호
    - 프록시 기능의 한계로 지연로딩을 설정해도 항상 즉시 로딩됨

4. 다대다[N:M] - @ManyToMany
    => 실무에서는 사용하면 안된다.


# 책 추천

1. 객체 지향의 사실과 오해
2. 오브젝트


